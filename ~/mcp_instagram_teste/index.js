const { Server } = require("@modelcontextprotocol/sdk/server/index.js");
const { StdioServerTransport } = require("@modelcontextprotocol/sdk/server/stdio.js");
const { CallToolRequestSchema, ListToolsRequestSchema } = require("@modelcontextprotocol/sdk/types.js");
const { z } = require("zod");
const axios = require("axios");
const dotenv = require("dotenv");

dotenv.config();

// Configura√ß√µes da API
const igUserId = process.env.INSTAGRAM_USER_ID;
const accessToken = process.env.INSTAGRAM_ACCESS_TOKEN;
const apiVersion = process.env.API_VERSION || "v22.0";
const baseUrl = process.env.BASE_URL || "https://graph.instagram.com";

console.log("üîê Vari√°veis de ambiente carregadas:");
console.log("INSTAGRAM_USER_ID:", process.env.INSTAGRAM_USER_ID ? "***" + process.env.INSTAGRAM_USER_ID.slice(-4) : "n√£o definido");
console.log("INSTAGRAM_ACCESS_TOKEN:", process.env.INSTAGRAM_ACCESS_TOKEN ? "***" + process.env.INSTAGRAM_ACCESS_TOKEN.slice(-4) : "n√£o definido");
console.log("API_VERSION:", apiVersion);
console.log("BASE_URL:", baseUrl);

const schemas = {
  toolInputs: {
    send_dm: z.object({
      recipientId: z.string(),
      text: z.string().optional(),
      mediaUrl: z.string().optional(),
      mediaType: z.enum(["image", "video", "audio"]).optional(),
      link: z.string().optional()
    }),
    send_image: z.object({
      recipientId: z.string(),
      imageUrl: z.string(),
      caption: z.string().optional()
    }),
    send_media: z.object({
      recipientId: z.string(),
      mediaUrl: z.string(),
      mediaType: z.enum(["audio", "video"]),
      caption: z.string().optional()
    }),
    send_sticker: z.object({
      recipientId: z.string()
    }),
    share_post: z.object({
      recipientId: z.string(),
      postId: z.string()
    }),
  }
};

// Defini√ß√µes das ferramentas dispon√≠veis
const TOOL_DEFINITIONS = [
  {
    name: "send_dm",
    description: "Envia mensagem direta para usu√°rio do Instagram",
    inputSchema: {
      type: "object",
      properties: {
        recipientId: { type: "string", description: "Instagram-scoped ID (IGSID) do destinat√°rio" },
        text: { type: "string", description: "Texto da mensagem (opcional)" },
        mediaUrl: { type: "string", description: "URL da m√≠dia a ser enviada (opcional)" },
        mediaType: { type: "string", enum: ["image", "video", "audio"], description: "Tipo de m√≠dia (opcional)" },
        link: { type: "string", description: "Link para incluir na mensagem (opcional)" }
      },
      required: ["recipientId"]
    }
  },
  {
    name: "send_image",
    description: "Envia uma imagem ou GIF para um usu√°rio do Instagram",
    inputSchema: {
      type: "object",
      properties: {
        recipientId: { type: "string", description: "Instagram-scoped ID (IGSID) do destinat√°rio" },
        imageUrl: { type: "string", description: "URL da imagem ou GIF a ser enviada" },
        caption: { type: "string", description: "Texto opcional para acompanhar a imagem" }
      },
      required: ["recipientId", "imageUrl"]
    }
  },
  {
    name: "send_media",
    description: "Envia √°udio ou v√≠deo para um usu√°rio do Instagram",
    inputSchema: {
      type: "object",
      properties: {
        recipientId: { type: "string", description: "Instagram-scoped ID (IGSID) do destinat√°rio" },
        mediaUrl: { type: "string", description: "URL do arquivo de √°udio ou v√≠deo" },
        mediaType: { type: "string", enum: ["audio", "video"], description: "Tipo de m√≠dia (audio ou video)" },
        caption: { type: "string", description: "Texto opcional para acompanhar a m√≠dia" }
      },
      required: ["recipientId", "mediaUrl", "mediaType"]
    }
  },
  {
    name: "send_sticker",
    description: "Envia um sticker de cora√ß√£o para um usu√°rio do Instagram",
    inputSchema: {
      type: "object",
      properties: {
        recipientId: { type: "string", description: "Instagram-scoped ID (IGSID) do destinat√°rio" }
      },
      required: ["recipientId"]
    }
  },
  {
    name: "share_post",
    description: "Compartilha um post do Instagram com um usu√°rio",
    inputSchema: {
      type: "object",
      properties: {
        recipientId: { type: "string", description: "Instagram-scoped ID (IGSID) do destinat√°rio" },
        postId: { type: "string", description: "ID do post a ser compartilhado" }
      },
      required: ["recipientId", "postId"]
    }
  }
];

// Implementa√ß√£o dos manipuladores das ferramentas
const toolHandlers = {
  send_dm: async (args) => {
    const parsed = schemas.toolInputs.send_dm.parse(args);
    
    try {
      // Verificar se temos o ID do destinat√°rio
      if (!parsed.recipientId) {
        throw new Error("ID do destinat√°rio (IGSID) √© obrigat√≥rio");
      }
      
      // Construir o objeto de mensagem
      const messageObj = {};
      
      // Adicionar texto se fornecido
      if (parsed.text) {
        // Verificar tamanho do texto (m√°ximo 1000 bytes)
        const textBytes = Buffer.from(parsed.text, 'utf8').length;
        if (textBytes > 1000) {
          throw new Error("Texto excede o limite de 1000 bytes");
        }
        messageObj.text = parsed.text;
      }
      
      // Adicionar link se fornecido
      if (parsed.link) {
        // Verificar se √© uma URL v√°lida
        try {
          new URL(parsed.link);
        } catch (e) {
          throw new Error("O link fornecido n√£o √© uma URL v√°lida");
        }
        
        // Se j√° tiver texto, adiciona o link ao final
        if (messageObj.text) {
          messageObj.text += "\n" + parsed.link;
        } else {
          messageObj.text = parsed.link;
        }
      }
      
      // Adicionar m√≠dia se fornecida
      if (parsed.mediaUrl) {
        if (!parsed.mediaType) {
          throw new Error("mediaType √© obrigat√≥rio quando mediaUrl √© fornecido");
        }
        
        // Verificar tipo de m√≠dia e definir o formato correto
        let attachmentType;
        switch(parsed.mediaType) {
          case "image":
            attachmentType = "image";
            // Verificar formato da imagem (png, jpeg, gif)
            if (!parsed.mediaUrl.match(/\.(png|jpe?g|gif)$/i)) {
              console.warn("‚ö†Ô∏è Aviso: URL da imagem n√£o parece ter um formato suportado (png, jpeg, gif)");
            }
            break;
          case "video":
            attachmentType = "video";
            // Verificar formato do v√≠deo (mp4, ogg, avi, mov, webm)
            if (!parsed.mediaUrl.match(/\.(mp4|ogg|avi|mov|webm)$/i)) {
              console.warn("‚ö†Ô∏è Aviso: URL do v√≠deo n√£o parece ter um formato suportado (mp4, ogg, avi, mov, webm)");
            }
            break;
          case "audio":
            attachmentType = "audio";
            // Verificar formato do √°udio (aac, m4a, wav, mp4)
            if (!parsed.mediaUrl.match(/\.(aac|m4a|wav|mp4)$/i)) {
              console.warn("‚ö†Ô∏è Aviso: URL do √°udio n√£o parece ter um formato suportado (aac, m4a, wav, mp4)");
            }
            break;
          default:
            throw new Error("mediaType deve ser 'image', 'video' ou 'audio'");
        }
        
        // Adicionar attachment conforme o tipo de m√≠dia
        messageObj.attachment = {
          type: attachmentType,
          payload: {
            url: parsed.mediaUrl
          }
        };
      }
      
      // Verificar se h√° conte√∫do para enviar
      if (Object.keys(messageObj).length === 0) {
        throw new Error("√â necess√°rio fornecer texto, link ou m√≠dia para enviar");
      }
      
      // Construir payload completo conforme documenta√ß√£o
      const payload = {
        recipient: { id: parsed.recipientId },
        message: messageObj
      };
      
      console.log("üì§ Enviando mensagem para:", parsed.recipientId);
      console.log("üìù Conte√∫do:", JSON.stringify(messageObj, null, 2));
      
      // Em modo de teste, simular uma resposta bem-sucedida
      if (!igUserId || !accessToken) {
        console.log("üîî Modo de teste: simulando resposta da API");
        
        return {
          content: [{
            type: "text",
            text: `[SIMULA√á√ÉO] Mensagem enviada com sucesso!\nID da mensagem: msg_${Date.now()}\nID do destinat√°rio: ${parsed.recipientId}`
          }]
        };
      }
      
      // Fazer requisi√ß√£o √† API do Instagram conforme documenta√ß√£o
      const url = `${baseUrl}/${apiVersion}/${igUserId}/messages`;
      console.log("üîó URL da API:", url);
      
      const response = await axios({
        method: 'post',
        url: url,
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        data: payload
      });
      
      console.log("‚úÖ Mensagem enviada com sucesso!");
      console.log("üìä Resposta da API:", response.data);
      
      return {
        content: [{
          type: "text",
          text: `Mensagem enviada com sucesso!\nID da mensagem: ${response.data.message_id}\nID do destinat√°rio: ${parsed.recipientId}`
        }]
      };
    } catch (error) {
      console.error("‚ùå Erro ao enviar mensagem:", {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status
      });
      
      return {
        content: [{
          type: "text",
          text: `Erro ao enviar mensagem: ${error.message}\nDetalhes: ${JSON.stringify(error.response?.data || {}, null, 2)}`
        }]
      };
    }
  },
  
  send_image: async (args) => {
    const parsed = schemas.toolInputs.send_image.parse(args);
    
    try {
      // Verificar se o URL da imagem √© v√°lido
      try {
        new URL(parsed.imageUrl);
      } catch (e) {
        throw new Error("URL da imagem inv√°lido");
      }
      
      // Verificar formato da imagem
      if (!parsed.imageUrl.match(/\.(png|jpe?g|gif)$/i)) {
        console.warn("‚ö†Ô∏è Aviso: URL da imagem n√£o parece ter um formato suportado (png, jpeg, gif)");
      }
      
      // Construir o payload da mensagem
      const messageObj = {
        attachment: {
          type: "image",
          payload: {
            url: parsed.imageUrl
          }
        }
      };
      
      // Adicionar caption se fornecido
      if (parsed.caption) {
        // Enviar em uma mensagem separada para garantir compatibilidade
        try {
          const captionPayload = {
            recipient: { id: parsed.recipientId },
            message: { text: parsed.caption }
          };
          
          // Em modo de teste, simular envio da legenda
          if (!igUserId || !accessToken) {
            console.log("üîî Modo de teste: simulando envio de legenda");
          } else {
            await axios({
              method: 'post',
              url: `${baseUrl}/${apiVersion}/${igUserId}/messages`,
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
              },
              data: captionPayload
            });
          }
          
          console.log("‚úÖ Legenda enviada com sucesso!");
        } catch (captionError) {
          console.warn("‚ö†Ô∏è Erro ao enviar legenda:", captionError.message);
        }
      }
      
      // Construir payload completo
      const payload = {
        recipient: { id: parsed.recipientId },
        message: messageObj
      };
      
      console.log("üì§ Enviando imagem para:", parsed.recipientId);
      console.log("üñºÔ∏è URL da imagem:", parsed.imageUrl);
      
      // Em modo de teste, simular uma resposta bem-sucedida
      if (!igUserId || !accessToken) {
        console.log("üîî Modo de teste: simulando resposta da API");
        
        return {
          content: [{
            type: "text",
            text: `[SIMULA√á√ÉO] Imagem enviada com sucesso!\nID da mensagem: msg_${Date.now()}\nID do destinat√°rio: ${parsed.recipientId}`
          }]
        };
      }
      
      // Fazer requisi√ß√£o √† API do Instagram
      const url = `${baseUrl}/${apiVersion}/${igUserId}/messages`;
      const response = await axios({
        method: 'post',
        url: url,
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        data: payload
      });
      
      console.log("‚úÖ Imagem enviada com sucesso!");
      return {
        content: [{
          type: "text",
          text: `Imagem enviada com sucesso!\nID da mensagem: ${response.data.message_id}\nID do destinat√°rio: ${parsed.recipientId}`
        }]
      };
    } catch (error) {
      console.error("‚ùå Erro ao enviar imagem:", {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status
      });
      
      return {
        content: [{
          type: "text",
          text: `Erro ao enviar imagem: ${error.message}\nDetalhes: ${JSON.stringify(error.response?.data || {}, null, 2)}`
        }]
      };
    }
  },
  
  send_media: async (args) => {
    const parsed = schemas.toolInputs.send_media.parse(args);
    
    try {
      // Verificar se o URL da m√≠dia √© v√°lido
      try {
        new URL(parsed.mediaUrl);
      } catch (e) {
        throw new Error("URL da m√≠dia inv√°lido");
      }
      
      // Verificar formato da m√≠dia baseado no tipo
      if (parsed.mediaType === "video") {
        if (!parsed.mediaUrl.match(/\.(mp4|ogg|avi|mov|webm)$/i)) {
          console.warn("‚ö†Ô∏è Aviso: URL do v√≠deo n√£o parece ter um formato suportado (mp4, ogg, avi, mov, webm)");
        }
      } else if (parsed.mediaType === "audio") {
        if (!parsed.mediaUrl.match(/\.(aac|m4a|wav|mp4)$/i)) {
          console.warn("‚ö†Ô∏è Aviso: URL do √°udio n√£o parece ter um formato suportado (aac, m4a, wav, mp4)");
        }
      }
      
      // Construir o payload da mensagem
      const messageObj = {
        attachment: {
          type: parsed.mediaType,
          payload: {
            url: parsed.mediaUrl
          }
        }
      };
      
      // Adicionar caption se fornecido
      if (parsed.caption) {
        // Enviar em uma mensagem separada para garantir compatibilidade
        try {
          const captionPayload = {
            recipient: { id: parsed.recipientId },
            message: { text: parsed.caption }
          };
          
          // Em modo de teste, simular envio da legenda
          if (!igUserId || !accessToken) {
            console.log("üîî Modo de teste: simulando envio de legenda");
          } else {
            await axios({
              method: 'post',
              url: `${baseUrl}/${apiVersion}/${igUserId}/messages`,
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
              },
              data: captionPayload
            });
          }
          
          console.log("‚úÖ Legenda enviada com sucesso!");
        } catch (captionError) {
          console.warn("‚ö†Ô∏è Erro ao enviar legenda:", captionError.message);
        }
      }
      
      // Construir payload completo
      const payload = {
        recipient: { id: parsed.recipientId },
        message: messageObj
      };
      
      console.log(`üì§ Enviando ${parsed.mediaType === "audio" ? "√°udio" : "v√≠deo"} para:`, parsed.recipientId);
      console.log("üîó URL da m√≠dia:", parsed.mediaUrl);
      
      // Em modo de teste, simular uma resposta bem-sucedida
      if (!igUserId || !accessToken) {
        console.log("üîî Modo de teste: simulando resposta da API");
        
        return {
          content: [{
            type: "text",
            text: `[SIMULA√á√ÉO] ${parsed.mediaType === "audio" ? "√Åudio" : "V√≠deo"} enviado com sucesso!\nID da mensagem: msg_${Date.now()}\nID do destinat√°rio: ${parsed.recipientId}`
          }]
        };
      }
      
      // Fazer requisi√ß√£o √† API do Instagram
      const url = `${baseUrl}/${apiVersion}/${igUserId}/messages`;
      const response = await axios({
        method: 'post',
        url: url,
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        data: payload
      });
      
      console.log(`‚úÖ ${parsed.mediaType === "audio" ? "√Åudio" : "V√≠deo"} enviado com sucesso!`);
      return {
        content: [{
          type: "text",
          text: `${parsed.mediaType === "audio" ? "√Åudio" : "V√≠deo"} enviado com sucesso!\nID da mensagem: ${response.data.message_id}\nID do destinat√°rio: ${parsed.recipientId}`
        }]
      };
    } catch (error) {
      console.error(`‚ùå Erro ao enviar ${parsed.mediaType === "audio" ? "√°udio" : "v√≠deo"}:`, {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status
      });
      
      return {
        content: [{
          type: "text",
          text: `Erro ao enviar ${parsed.mediaType === "audio" ? "√°udio" : "v√≠deo"}: ${error.message}\nDetalhes: ${JSON.stringify(error.response?.data || {}, null, 2)}`
        }]
      };
    }
  },
  
  send_sticker: async (args) => {
    const parsed = schemas.toolInputs.send_sticker.parse(args);
    
    try {
      // Construir o payload da mensagem com sticker de cora√ß√£o
      const messageObj = {
        attachment: {
          type: "like_heart"
        }
      };
      
      // Construir payload completo
      const payload = {
        recipient: { id: parsed.recipientId },
        message: messageObj
      };
      
      console.log("üì§ Enviando sticker de cora√ß√£o para:", parsed.recipientId);
      
      // Em modo de teste, simular uma resposta bem-sucedida
      if (!igUserId || !accessToken) {
        console.log("üîî Modo de teste: simulando resposta da API");
        
        return {
          content: [{
            type: "text",
            text: `[SIMULA√á√ÉO] Sticker enviado com sucesso!\nID da mensagem: msg_${Date.now()}\nID do destinat√°rio: ${parsed.recipientId}`
          }]
        };
      }
      
      // Fazer requisi√ß√£o √† API do Instagram
      const url = `${baseUrl}/${apiVersion}/${igUserId}/messages`;
      const response = await axios({
        method: 'post',
        url: url,
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        data: payload
      });
      
      console.log("‚úÖ Sticker enviado com sucesso!");
      return {
        content: [{
          type: "text",
          text: `Sticker enviado com sucesso!\nID da mensagem: ${response.data.message_id}\nID do destinat√°rio: ${parsed.recipientId}`
        }]
      };
    } catch (error) {
      console.error("‚ùå Erro ao enviar sticker:", {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status
      });
      
      return {
        content: [{
          type: "text",
          text: `Erro ao enviar sticker: ${error.message}\nDetalhes: ${JSON.stringify(error.response?.data || {}, null, 2)}`
        }]
      };
    }
  },
  
  share_post: async (args) => {
    const parsed = schemas.toolInputs.share_post.parse(args);
    
    try {
      // Construir o payload da mensagem com o post compartilhado
      const messageObj = {
        attachment: {
          type: "MEDIA_SHARE",
          payload: {
            id: parsed.postId
          }
        }
      };
      
      // Construir payload completo
      const payload = {
        recipient: { id: parsed.recipientId },
        message: messageObj
      };
      
      console.log("üì§ Compartilhando post com:", parsed.recipientId);
      console.log("üÜî ID do post:", parsed.postId);
      
      // Em modo de teste, simular uma resposta bem-sucedida
      if (!igUserId || !accessToken) {
        console.log("üîî Modo de teste: simulando resposta da API");
        
        return {
          content: [{
            type: "text",
            text: `[SIMULA√á√ÉO] Post compartilhado com sucesso!\nID da mensagem: msg_${Date.now()}\nID do destinat√°rio: ${parsed.recipientId}\nID do post: ${parsed.postId}`
          }]
        };
      }
      
      // Fazer requisi√ß√£o √† API do Instagram
      const url = `${baseUrl}/${apiVersion}/${igUserId}/messages`;
      const response = await axios({
        method: 'post',
        url: url,
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        data: payload
      });
      
      console.log("‚úÖ Post compartilhado com sucesso!");
      return {
        content: [{
          type: "text",
          text: `Post compartilhado com sucesso!\nID da mensagem: ${response.data.message_id}\nID do destinat√°rio: ${parsed.recipientId}\nID do post: ${parsed.postId}`
        }]
      };
    } catch (error) {
      console.error("‚ùå Erro ao compartilhar post:", {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status
      });
      
      return {
        content: [{
          type: "text",
          text: `Erro ao compartilhar post: ${error.message}\nDetalhes: ${JSON.stringify(error.response?.data || {}, null, 2)}`
        }]
      };
    }
  }
};

// Configurar o servidor MCP
const server = new Server({
  name: "instagram-tools-server",
  version: "1.0.0",
}, {
  capabilities: {
    tools: {},
  },
});

// Registrar os manipuladores de requisi√ß√µes
server.setRequestHandler(ListToolsRequestSchema, async () => {
  console.error("Ferramenta requisitada pelo cliente");
  return { tools: TOOL_DEFINITIONS };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  try {
    const handler = toolHandlers[name];
    if (!handler) throw new Error(`Tool Desconhecida: ${name}`);
    return await handler(args);
  } catch (error) {
    console.error(`Error executando a tool ${name}:`, error);
    throw error;
  }
});

// Iniciar o servidor
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Instagram API MPC Server rodando no stdio");
}

main().catch(console.error);
